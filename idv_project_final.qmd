---
title: "IDV project"
author: "Maikki Heijala"
format: 
  dashboard:
    orientation: columns
    expandable: false
---
```{r data_handling}
#| include: false
#| warning: false

library(rjson)
library(dplyr)
library(purrr)

for_rent <- fromJSON(file="for_rent.json")
for_rent2 <- fromJSON(file="for_rent2.json")
for_sale <- fromJSON(file="for_sale.json")
age <- fromJSON(file="age4.json")
education <- fromJSON(file="education3.json")

codes_names <- as.data.frame(
  do.call(
    rbind,
    for_rent$dataset$dimension$Postinumero$category$label
  )
)
codes_names$names <- rownames(codes_names)
names <- codes_names$V1

filtered_for_sale <- 
  tibble(
    info = map(for_sale$data, "key"),
    price = map_chr(for_sale$data, "values")
  ) %>% 
  mutate(
    year = map_chr(info, 1),
    code = map_chr(info, 2) 
  ) %>%
  select(
    code, year, price
  ) %>%
  mutate(
    price = as.integer((price)),
    year = substring(year, 1, 4)
  ) %>%
  na.omit() %>%
  group_by(code, year) %>%
  summarise(price_avg = mean(price)) %>%
  mutate(price_avg = round(price_avg, 0))

filtered_for_rent <- 
  tibble(
    info = map(for_rent2$data, "key"),
    price = map_chr(for_rent2$data, "values")
  ) %>% 
  mutate(
    year = map_chr(info, 1),
    code = map_chr(info, 2) 
  ) %>%
  select(
    code, year, price
  ) %>%
  mutate(
    price = as.integer((price)),
    year = substring(year, 1, 4)
  ) %>%
  na.omit() %>%
  group_by(code, year) %>%
  summarise(price_avg = mean(price)) %>%
  mutate(price_avg = round(price_avg, 0))

# These min and max value stay the same so they can be calculated in R
sale_max_all = max(filtered_for_sale$price_avg)
sale_min_all = min(filtered_for_sale$price_avg)
rent_max_all = max(filtered_for_rent$price_avg)
rent_min_all = min(filtered_for_rent$price_avg)

ojs_define(names)
ojs_define(for_sale)
ojs_define(for_rent)
ojs_define(age)
ojs_define(education)
ojs_define(filtered_for_sale)
ojs_define(filtered_for_rent)
ojs_define(sale_max_all)
ojs_define(sale_min_all)
ojs_define(rent_max_all)
ojs_define(rent_min_all)

```

## Column {width="30%"}

```{r}
#| title: "Ales Price Averages on  Map"
#| padding: 10px

library(dplyr)
library(leaflet)
library(geojsonsf)
library(rjson)
library(sf)

geo_data <- geojson_sf("finland-postal-codes.geojson")

# Sales data of 2023 to the map
for_sale_2023 <- filtered_for_sale %>%
  filter(year ==2023)

geo_data <- left_join(
  geo_data, 
  for_sale_2023, 
  by = c("postinumeroalue" = "code")
)

my_colors = c('#247800', '#839168', '#b59fa3', '#ffb1ff')  

bins <- c(0, 2000, 5000, 7000, Inf)
pal <- colorBin(my_colors, domain = c(0, 10000), bins = bins)

labels <- sprintf(
  "<strong>%s</strong> euros / m<sup>2</sup><br/>area: %s",
  geo_data$price_avg,
  geo_data$postinumeroalue
) %>% lapply(htmltools::HTML)


m <- leaflet(geo_data) %>%
  addProviderTiles("MapBox", options = providerTileOptions(
  id = "mapbox.light",
  accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN'))) %>%
  setView(lat = 64, lng = 26, zoom = 5) %>%
  addPolygons(
    fillColor = ~pal(as.numeric(geo_data$price_avg)),
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    highlightOptions = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE),
    label = labels
    )

m %>% addLegend(pal = pal, values = as.numeric(geo_data$price_avg), opacity = 0.7, title = NULL,
  position = "bottomright")

```

## Column

### Row {height=60%}

#### Column

#### Row

```{ojs}
//| title: Area selection

viewof chosen_area = Inputs.select(names)

header_name = chosen_area.split(' (')[0];
chosen_code = header_name.split(' ')[0]

// Tile value calculations here so they won't show on site
max_tile = Math.max.apply(Math, tiledata.map(function(o) { return o.price_avg }))
min_tile = Math.min.apply(Math, tiledata.map(function(o) { return o.price_avg }))

function get_tiledata(m) {
  if (m == "for sale") {
    return [sale_max_all, sale_min_all]
  }
  return [rent_max_all, rent_min_all]
}

prize_max_area = max_tile
prize_min_area = min_tile

fin_tiles = get_tiledata(market)
prize_max_all = fin_tiles[0]
prize_min_all = fin_tiles[1]
```

##### Column

```{ojs valuebox_high_area}
//| padding: 0px
//| fill: true

Plot.plot({
  marks: [
    Plot.frame({fill: "#247800"}),
    Plot.text(["\nHighest e/m2 in area " + market], {frameAnchor: "top", fontSize: 18, fontWeight: "bold"}),
    Plot.text([prize_max_area], {frameAnchor: "middle", fontSize: 50, fontWeight: "bold"})
  ]
})
```

##### Column

```{ojs valuebox_low_area}
//| padding: 0px

Plot.plot({
  marks: [
    Plot.frame({fill: "#ffb1ff" }),
    Plot.text(["\nLowest e/m2 in area " + market], {frameAnchor: "top", fontSize: 18, fontWeight: "bold"}),
    Plot.text([prize_min_area], {frameAnchor: "middle", fontSize: 50, fontWeight: "bold"})
  ]
})
```

#### Row

```{ojs}
//| title: Market type selection

viewof market = Inputs.radio(["for rent", "for sale"], {value: "for rent"})

```

##### Column

```{ojs valuebox_high_finland}
//| padding: 0px

Plot.plot({
  marks: [
    Plot.frame({fill: "#ece5dd" }),
    Plot.text(["\nHighest e/m2 in Finland"], {frameAnchor: "top", fontSize: 18, fontWeight: "bold"}),
    Plot.text([prize_max_all], {frameAnchor: "middle", fontSize: 50, fontWeight: "bold"})
  ]
})
```

##### Column

```{ojs valuebox_low_finland}
//| padding: 0px

Plot.plot({
  marks: [
    Plot.frame({fill: "#ece5dd" }),
    Plot.text(["\nLowest e/m2 in Finland"], {frameAnchor: "top", fontSize: 18, fontWeight: "bold"}),
    Plot.text([prize_min_all], {frameAnchor: "middle", fontSize: 50, fontWeight: "bold"})
  ]
})
```

#### Column

```{ojs}
//| title: 5 year development

html`<h4>${header_name}</h4>`

function get_linedata(m) {
  if (m == "for sale") {
    return [filtered_for_sale, 10000]
  }
  return [filtered_for_rent, 50]
}

linedata = get_linedata(market)
data = transpose(linedata[0])
y_limit = linedata[1]

t_linedata = data.filter(row => row.code === chosen_code)

tiledata = t_linedata

Plot.plot({
  marginTop: 50,
  marginRight: 50,
  marginBottom: 50,
  marginLeft: 50,
  height: 400,
  width: 350,
  y: {
    grid: true,
    domain: [0, y_limit],
    label: "price/m2"
  },
  x: {
    domain: [2019, 2023],
    tickFormat: "",
    interval: 1
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(t_linedata, {x: "year", y: "price_avg", channels: {year: "year", price_avg: "price"}, tip: true}),
    Plot.areaY(t_linedata, {x: "year", y: "price_avg", fillOpacity: 0.1}),
    Plot.lineY(t_linedata, {x: "year", y: "price_avg"}),
    Plot.frame()
  ]
})

// Age data handling here so it won't show on the Age card
agedata = age.data.filter(row => row.key === chosen_code)
  .map(row => row.values)[0]

age_groups = sum_pairs(agedata)
age_labels = ["0-6", "7-15", "16-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80-"]

age_combi = [age_labels, age_groups]
  
function sum_pairs(arr) {
  const grouped_ages = []
  for (let i = 0; i < 20; i += 2) {
    grouped_ages.push(Math.round(Number(arr[i])+Number(arr[i+1])))
  }
  return grouped_ages
}

// Education data handling

edudata = education.data.filter(row => row.key === chosen_code)
  .map(row => row.values)[0]
  
edudata_holder = edudata.splice(1, 1)

edu_labels = ["basic level", "matriculation\nexamination", "vocational\ndiploma", "lower\nacademic", "higher\nacademic"]

edu_combi = [edu_labels, edudata]

```

### Row

```{ojs}
//| title: Age

ageplot = Plot.plot({
  x: {padding: 0.4},
  y: {
    grid: true,
    label: "%",
    domain: [0, 20],
  },
  marks: [
    Plot.barY(age_groups, {x: age_labels})
  ]
})

```


```{ojs}
//| title: Education

eduplot = Plot.plot({
  x: {padding: 0.4},
  y: {
    grid: true,
    label: "%",
    domain: [0, 20],
  },
  marks: [
    Plot.barY(edudata, {x: edu_labels})
  ]
})

```
